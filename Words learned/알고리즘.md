# 알고리즘

<aside>
💡 알고리즘은 문제를 해결하기 위한 단계적인 절차나 규칙의 집합이다.

</aside>

### 알고리즘의 조건

- 입력 (Input) ; 알고리즘이 작동하기 위해서는 입력 데이터가 명확하게 정의되어야 한다.
- 출력 (Output) ; 알고리즘이 입력을 기반으로 최소 1개 이상의 결과를 생성하는데 명확하게 정의되어야 한다. 이는 알고리즘의 목적을 달성하는데 사용된다.
- 명확성 (Definiteness) ; 각 단계가 모호하지 않고 명확하게 정의되어야 한다.
- 유한성 (Finiteness) ; 알고리즘이 유한한 단계 내에서 실행을 완료해야 한다. 무한 루프에 빠지면 안된다.
- 효과성 (Effectiveness) ; 모든 연산을 유한한 시간 내에 효과적으로 해결해야 한다. 알고리즘은 단순해야 하고 Input이 커질수록 성능이 향상되어야 한다.

### 좋은 알고리즘이란?

프로그램의 품질은 알고리즘의 좋고, 나쁨에 따라 달린다고 한다.

여기서 좋은 알고리즘이란 **다양한 요인을 고려하여 설계**되며 특정 문제를 **효과적으로 해결**할 수 있는 알고리즘이다.

좋은 알고리즘의 특징을 알아보자.

1. 효율성 ; 가능한 빠르고 정확하게 동작해야 한다. 실행 시간이나 필요한 자원을 최소한으로 사용해야 하고 입력 데이터에 대해 올바른 출력을 생성해야 한다.
2. 확장성 ; 입력 데이터의 크기에 따라 성능이 적절하게 조절되어야 한다. 작거나 큰 입력에 구애받지 않고 모두 효율적으로 작동해야 한다.
3. 간결성 ; 가능한 간결하고 이해하기 쉬워야 한다. 또한 수정 및 유지 보수를 하기 쉬워야 하며 코드를 변경하거나 개선할 때 다른 부분에 부작용을 일으키지 않아야 한다.
4. 일반성 ; 틀정 문제뿐만 아니라 관련된 다른 문제에 대해서도 적용이 가능해야 한다. 가능한 많은 문제에 사용할 수 있는 알고리즘일수록 가치가 있다.
5. 안정성 ; 다양한 입력 조건에서 안정적으로 동작해야 하며 예외 상황에 대한 처리가 강화되어야 한다. 잘못된 입력에 대한 처리 방안이 있어야 한다.

좋은 알고리즘은 주어진 문제의 복잡성과 목표에 따라 다르기 때문에 문제의 특성을 고려하여 선택해야 한다.

---

## 정렬 알고리즘

<aside>
💡 정렬 알고리즘이란 데이터를 일정 순서대로 배열하는 알고리즘이다.

</aside>

### 정렬 알고리즘의 종류

- 버블 정렬 ; 인접한 두 요소를 비교해서 큰 값을 뒤로 이동시키는 방식으로 정렬하는 알고리즘이다.
- 선택정렬 ; 리스트에서 최소값을 선택하고 그 값을 앞으로 이동시키는 방식으로 정렬하는 알고리즘이다.
- 삽입 정렬 ; 리스트에서 자신의 값과 좌측 값을 비교하여 자신보다 작은 값이 나올때까지 우측으로 밀어서 삽입하는 정렬이다.
- 병합 정렬 ; 리스트를 반으로 나누고 이를 재귀적으로 정렬한 다음 병합해서 정렬하는 방법으로 동작한다.
- 퀵 정렬 ; pivot을 기준으로 작은 값과 큰 값으로 분할하고 각 부분을 재귀적으로 정렬한다.
- 힙 정렬 ; 이진 힙 자료구조를 사용하여 정렬하는 알고리즘으로, 최대 힙을 구성한 다음 루트 노드를 추출하여 정렬한다.
- 기수 정렬 ; 비교가 아닌 정수나 문자열을 비트나 자릿수 기준으로 정렬하는 알고리즘이다.
- 버킷 정렬 ; 데이터를 일정한 버킷에 할당하고, 각 버킷을 개별적으로 정렬한 다음 합치는 방식으로 동작하는 알고리즘이다.
- 외부 정렬 ; 대용량의 데이터를 부분적으로 주기억 장치에 읽어 들이고, 내부정렬 알고리즘(퀵 정렬 등)을 이용하여 정렬 후 다른 보조 기억 장치에 저장한다.
    - 외부 정렬 종류 ; 진동 병합, 캐스케이드 병합, 폴리파즈 병합, 균형 병합 정렬 등이 있다.
    

---

### 버블 정렬

개념 요약

- 서로 인접한 두 원소를 비교하며 정렬하는 알고리즘
- 정렬 과정에서 큰 값은 리스트의 뒷부분으로 이동하는 과정을 반복하며 리스트 전체를 정렬한다.

장점

- 작은 데이터에 대한 효율성 ; 데이터의 크기가 작고 정렬이 일부 되어있는 상태라면 다른 정렬 알고리즘보다 빠를 수 있다.
- 간단하고 이해하기 쉽다 ; 구현이 간단하며 알고리즘 자체의 동작 원리를 이해하기 쉽다.

단점

- 데이터 크기에 민감 ; 데이터 크기에 따라 성능이 크게 영향을 받는다. 데이터가 크다면 다른 정렬 알고리즘을 사용하는 것이 더 효율적이다.
- 다른 비교 기반 정렬 알고리즘 (퀵, 병합 정렬)등과 비교하면 성능이 떨어진다.

---

### 선택정렬

개념요약

- 제자리 정렬 알고리즘 중 하나이다.
    - 제자리 정렬 - 입력되어 있는 배열 이외에 추가적인 메모리를 요구하지 않는 방법
- 원소를 넣을 위치는 정해져 있고, 들어갈 원소를 선택하는 알고리즘이다.
    - ex) 첫번째 순서에는 최솟값 탐색 후 첫번째 위치에 최솟값 입력 → 두번째 순서에는 남은 수 중 최솟값 탐색 후 두번째 위치에 남은 값 중 최솟값 입력 …
- 고정된 값 외의 값을 차례대로 비교하여 가장 작은 값을 남은 위치에 넣는 것. 위 과정을 반복한다.

장점

- 구현이 간단하고 동작 원리를 이해하기 쉽다.
- 추가 메모리 요구량이 적다.
- 데이터 순서에 상관없이 일정한 성능을 보여준다.

단점

- 비효율적이고, 데이터 크기가 커질수록 알고리즘 성능이 급격히 저하된다.
- 비교 횟수가 고정되어있다.
- 불안정한 정렬 방법이다
    - 불안정한 정렬 - 같은 값의 원소 순서를 보존하지 않고 정렬 전과 정렬 후에 서로 다른 순서를 가지고 있는 것

---

### 삽입정렬

개념요약

- 정렬되지 않은 부분 중 첫 번째 원소를 선택하고 이미 정렬된 부분 중에서 원소가 들어갈 적합한 위치를 찾아 삽입한다.
- 공간 복잡도가 O(1)이고, 원소를 교활할때 쓰일 임시변수 정도의 추가공간만 필요하므로 in-place 정렬이다.
- 안정적인 정렬 알고리즘으로, 같은 값의 원소 순서를 보존한다.
- 선택 정렬이나 버블 정렬에 비해 상대적으로 빠르다.

장점

- 구현이 간단하고 이해하기 쉽다.
- 데이터의 크기가 작거나 이미 정렬된 경우에 매우 효율적이다.

단점 

- 이동 작업이 많다 ; 원소를 삽입하며 이동 작업이 많이 필요하여 성능이 저하될 수 있다.

---

### 병합 정렬

개념요약

- 안정 정렬에 속하며 분할 정복 알고리즘 중 하나이다.
    - 분할 정복 - 문제를 작은 문제로 분리한 다음 결과를 모아 본래 문제를 해결하는 방법
        - 분할 정복 방법은 대부분 순환 호출을 이용하여 구현한다.
- 하나의 리스트를 균등한 크기로 2분할을 계속 하고, 분할된 부분 리스트를 정렬 후 합쳐 전체가 정렬된 리스트가 되게끔 한다.
- 합병 정렬 과정 ; 분할 → 정렬(배열의 크기가 최소값이 아닐 시 순환호출을 사용하여 다시 분할) → 결합