# 알고리즘

<aside>
💡 알고리즘은 문제를 해결하기 위한 단계적인 절차나 규칙의 집합이다.

</aside>

### 알고리즘의 조건

- 입력 (Input) ; 알고리즘이 작동하기 위해서는 입력 데이터가 명확하게 정의되어야 한다.
- 출력 (Output) ; 알고리즘이 입력을 기반으로 최소 1개 이상의 결과를 생성하는데 명확하게 정의되어야 한다. 이는 알고리즘의 목적을 달성하는데 사용된다.
- 명확성 (Definiteness) ; 각 단계가 모호하지 않고 명확하게 정의되어야 한다.
- 유한성 (Finiteness) ; 알고리즘이 유한한 단계 내에서 실행을 완료해야 한다. 무한 루프에 빠지면 안된다.
- 효과성 (Effectiveness) ; 모든 연산을 유한한 시간 내에 효과적으로 해결해야 한다. 알고리즘은 단순해야 하고 Input이 커질수록 성능이 향상되어야 한다.

### 좋은 알고리즘이란?

프로그램의 품질은 알고리즘의 좋고, 나쁨에 따라 달린다고 한다.

여기서 좋은 알고리즘이란 **다양한 요인을 고려하여 설계**되며 특정 문제를 **효과적으로 해결**할 수 있는 알고리즘이다.

좋은 알고리즘의 특징을 알아보자.

1. 효율성 ; 가능한 빠르고 정확하게 동작해야 한다. 실행 시간이나 필요한 자원을 최소한으로 사용해야 하고 입력 데이터에 대해 올바른 출력을 생성해야 한다.
2. 확장성 ; 입력 데이터의 크기에 따라 성능이 적절하게 조절되어야 한다. 작거나 큰 입력에 구애받지 않고 모두 효율적으로 작동해야 한다.
3. 간결성 ; 가능한 간결하고 이해하기 쉬워야 한다. 또한 수정 및 유지 보수를 하기 쉬워야 하며 코드를 변경하거나 개선할 때 다른 부분에 부작용을 일으키지 않아야 한다.
4. 일반성 ; 틀정 문제뿐만 아니라 관련된 다른 문제에 대해서도 적용이 가능해야 한다. 가능한 많은 문제에 사용할 수 있는 알고리즘일수록 가치가 있다.
5. 안정성 ; 다양한 입력 조건에서 안정적으로 동작해야 하며 예외 상황에 대한 처리가 강화되어야 한다. 잘못된 입력에 대한 처리 방안이 있어야 한다.

좋은 알고리즘은 주어진 문제의 복잡성과 목표에 따라 다르기 때문에 문제의 특성을 고려하여 선택해야 한다.

---

## 정렬 알고리즘

<aside>
💡 정렬 알고리즘이란 데이터를 일정 순서대로 배열하는 알고리즘이다.

</aside>

### 정렬 알고리즘의 종류

- 버블 정렬 ; 인접한 두 요소를 비교해서 큰 값을 뒤로 이동시키는 방식으로 정렬하는 알고리즘이다.
- 선택정렬 ; 리스트에서 최소값을 선택하고 그 값을 앞으로 이동시키는 방식으로 정렬하는 알고리즘이다.
- 삽입 정렬 ; 리스트에서 자신의 값과 좌측 값을 비교하여 자신보다 작은 값이 나올때까지 우측으로 밀어서 삽입하는 정렬이다.
- 병합 정렬 ; 리스트를 반으로 나누고 이를 재귀적으로 정렬한 다음 병합해서 정렬하는 방법으로 동작한다.
- 퀵 정렬 ; pivot을 기준으로 작은 값과 큰 값으로 분할하고 각 부분을 재귀적으로 정렬한다.
- 힙 정렬 ; 이진 힙 자료구조를 사용하여 정렬하는 알고리즘으로, 최대 힙을 구성한 다음 루트 노드를 추출하여 정렬한다.
- 기수 정렬 ; 비교가 아닌 정수나 문자열을 비트나 자릿수 기준으로 정렬하는 알고리즘이다.
- 버킷 정렬 ; 데이터를 일정한 버킷에 할당하고, 각 버킷을 개별적으로 정렬한 다음 합치는 방식으로 동작하는 알고리즘이다.
- 외부 정렬 ; 대용량의 데이터를 부분적으로 주기억 장치에 읽어 들이고, 내부정렬 알고리즘(퀵 정렬 등)을 이용하여 정렬 후 다른 보조 기억 장치에 저장한다.
    - 외부 정렬 종류 ; 진동 병합, 캐스케이드 병합, 폴리파즈 병합, 균형 병합 정렬 등이 있다.
    

---

### 버블 정렬

개념 요약

- 서로 인접한 두 원소를 비교하며 정렬하는 알고리즘
- 정렬 과정에서 큰 값은 리스트의 뒷부분으로 이동하는 과정을 반복하며 리스트 전체를 정렬한다.

장점

- 작은 데이터에 대한 효율성 ; 데이터의 크기가 작고 정렬이 일부 되어있는 상태라면 다른 정렬 알고리즘보다 빠를 수 있다.
- 간단하고 이해하기 쉽다 ; 구현이 간단하며 알고리즘 자체의 동작 원리를 이해하기 쉽다.

단점

- 데이터 크기에 민감 ; 데이터 크기에 따라 성능이 크게 영향을 받는다. 데이터가 크다면 다른 정렬 알고리즘을 사용하는 것이 더 효율적이다.
- 다른 비교 기반 정렬 알고리즘 (퀵, 병합 정렬)등과 비교하면 성능이 떨어진다.

---

### 선택정렬

개념요약

- 제자리 정렬 알고리즘 중 하나이다.
    - 제자리 정렬 - 입력되어 있는 배열 이외에 추가적인 메모리를 요구하지 않는 방법
- 원소를 넣을 위치는 정해져 있고, 들어갈 원소를 선택하는 알고리즘이다.
    - ex) 첫번째 순서에는 최솟값 탐색 후 첫번째 위치에 최솟값 입력 → 두번째 순서에는 남은 수 중 최솟값 탐색 후 두번째 위치에 남은 값 중 최솟값 입력 …
- 고정된 값 외의 값을 차례대로 비교하여 가장 작은 값을 남은 위치에 넣는 것. 위 과정을 반복한다.

장점

- 구현이 간단하고 동작 원리를 이해하기 쉽다.
- 추가 메모리 요구량이 적다.
- 데이터 순서에 상관없이 일정한 성능을 보여준다.

단점

- 비효율적이고, 데이터 크기가 커질수록 알고리즘 성능이 급격히 저하된다.
- 비교 횟수가 고정되어있다.
- 불안정한 정렬 방법이다
    - 불안정한 정렬 - 같은 값의 원소 순서를 보존하지 않고 정렬 전과 정렬 후에 서로 다른 순서를 가지고 있는 것

---

### 삽입정렬

개념요약

- 정렬되지 않은 부분 중 첫 번째 원소를 선택하고 이미 정렬된 부분 중에서 원소가 들어갈 적합한 위치를 찾아 삽입한다.
- 공간 복잡도가 O(1)이고, 원소를 교활할때 쓰일 임시변수 정도의 추가공간만 필요하므로 in-place 정렬이다.
- 안정적인 정렬 알고리즘으로, 같은 값의 원소 순서를 보존한다.
- 선택 정렬이나 버블 정렬에 비해 상대적으로 빠르다.

장점

- 구현이 간단하고 이해하기 쉽다.
- 데이터의 크기가 작거나 이미 정렬된 경우에 매우 효율적이다.

단점 

- 이동 작업이 많다 ; 원소를 삽입하며 이동 작업이 많이 필요하여 성능이 저하될 수 있다.

---

### 병합 정렬

개념요약

- 안정 정렬에 속하며 분할 정복 알고리즘 중 하나이다.
    - 분할 정복 - 문제를 작은 문제로 분리한 다음 결과를 모아 본래 문제를 해결하는 방법
        - 분할 정복 방법은 대부분 순환 호출을 이용하여 구현한다.
- 하나의 리스트를 균등한 크기로 2분할을 계속 하고, 분할된 부분 리스트를 정렬 후 합쳐 전체가 정렬된 리스트가 되게끔 한다.
- 합병 정렬 과정 ; 분할 → 정렬(배열의 크기가 최소값이 아닐 시 순환호출을 사용하여 다시 분할) → 결합
- 제자리 정렬이 아니다 ; 추가 메모리 공간 필요

장점

- 안정적이다 ; 입력 데이터 순서에 관계 없이 일정한 성능을 보장하고 효율적으로 동작하여 대규모 데이터에도 효율적이다.
- 외부 정렬에 적합하다 ; 대규모 데이터 정렬에 사용

단점 

- 추가 메모리 요구 ; 중간 결과를 저장하기 위해 추가 메모리가 필요하다
- 간단한 정렬 알고리즘(ex 버블, 선택 정렬)에 비해 상대적으로 느리다.

---

### 퀵정렬

개념요약

- 불안정 정렬이며 비교만으로 정렬을 수행하는 비교 정렬에 속한다.
- 합병 정렬과 다르게 리스트를 비균등하게 분할한다.
- 퀵정렬 과정 ; 리스트 안에서 피벗을 정한다. → 피벗을 기준으로 피벗보다 작은 요소들은 왼쪽으로, 피벗보다 큰 요소들은 오른쪽으로 옮긴다. → 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트에서도 피벗을 정해 나누는 과정을 반족한다.

장점

- 분할 정복 알고리즘이며, 수행 속도가 매우 빠르다.
- 추가 메모리 공간이 필요하지 않다.

단점

- 정렬된 리스트에 대해서는 비균등하게 분할하는 퀵 정렬에 의해 오히려 수행시간이 더 많이 걸린다.
- 피벗 선택 및 분할 방식에 따라 불안정한 정렬이 될 수 있다. → 방법을 최적화하지 않으면 불안정성이 부각될 수 있다.

---

### 힙정렬

자료구조 힙(heap) 이란?

- 완전 이진트리의 일종, 우선순위 큐를 위하여 만들어짐
- 최댓값, 최솟값을 쉽게 추출할 수 있다.

특징

- 최대 힙 트리나 최소 힙 트리를 구성해 정렬 하는 방법이다.
- 제자리 정렬이며 원소들을 비교해서 정렬하는 비교기반 정렬이다.
- 선택 정렬과 유사하지만 더 효율적으로 힙을 구성하고 원소를 추출한다.

장점

- 제자리 정렬이기에 메모리 사용량이 적다
- 상수 계수가 작을때에 효율적이다.

단점

- 불안정한 정렬 알고리즘이다.
- 다른 정렬 알고리즘(병합, 퀵 정렬)에 비해 상수 계수가 크기에 실제로 느릴 수 있다.
- 입력 데이터의 순서에 따라 정렬 속도가 다를 수 있다.

---

### 기수 정렬

<aside>
💡 기수들 간의 비교 없이 버킷을 사용해 정렬하는 정렬 알고리즘이다.

</aside>

특징

- 각 원소의 자릿수를 기준으로 정렬하는데, 일반적으로 낮은 자리에서 높은 자리 순으로 버킷을 넣는 방법으로 정렬된다.
- 비교 기반 정렬 알고리즘이 아니기에 비교 연산을 사용하지 않고, 안정한 정렬 알고리즘이다.
- 보편적으로 숫자 형태의 데이터를 정렬할때 사용하고 이뿐만 아니라 일반적인 데이터 형식에도 적용할 수 있지만, 주의가 필요하다.

장점

- 정렬 속도가 빠르다 ; 자릿수 별로 정렬을 수행하는 기수 정렬은 비교 기반 정렬 알고리즘들 보다 빠르고, 특히 데이터 자릿수가 작을 때 효과적이다.

단점 

- 데이터 자릿수가 길 경우 효과적이지 않다.
- 비교적 메모리 사용량이 높으며, 큰 범위의 데이터에는 부적합하다.

---

### 버킷정렬

특징

- 계수 정렬의 변형본이라고 볼 수 있다.
- 데이터가 균등하게 분포되어 있을 때 효과적으로 동작한다.
- 안정한 정렬 알고리즘이며, 비교 기반 정렬이 아니다.
- 입력 데이터를 여러 개의 버킷으로 나누고, 각 버킷 내에서 퀵 정렬을 통한 정렬을 하고 이를 전체적으로 합친다.

장점

- 다른 정렬 알고리즘에 비해 빠른 정렬 속도를 지니고 있다.
- 비교 기반 정렬 알고리즘보다 구현하기가 쉽다.

단점

- 데이터 분포에 민감하게 작동한다.
- 추가적 메모리를 요구한다.
- 버킷을 어떻게 설정하냐에 따라 정렬의 효율성이 달라진다.